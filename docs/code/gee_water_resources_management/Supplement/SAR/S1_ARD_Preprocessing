// Example script that shows how to pre-process SAR data
// 1) Using Refined Lee Filter
// 2) Using GAMMA MAP filter and Radiometric Terrain Correction

var gsw = ee.Image("JRC/GSW1_2/GlobalSurfaceWater");
var admin2 = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");
var hydrosheds = ee.Image("WWF/HydroSHEDS/03VFDEM");
    
var startDate = '2018-08-10'
var endDate = '2018-08-23'

var ernakulam = admin2.filter(ee.Filter.eq('ADM2_NAME', 'Ernakulam'))
var geometry = ernakulam.geometry()
Map.addLayer(geometry, {color: 'grey'}, 'Ernakulam District')

// ************************************************************
// Part 1: Refined Lee Filter
// ************************************************************
var collection= ee.ImageCollection('COPERNICUS/S1_GRD')
  .filter(ee.Filter.eq('instrumentMode','IW'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING')) 
  .filter(ee.Filter.eq('resolution_meters',10))
  .filter(ee.Filter.bounds(geometry))
  .select(['VV', 'VH'])


var filtered = collection.filter(ee.Filter.date(startDate, endDate))

// Function to add VV/VH ratio band
var addRatioBand = function(image) {
  var ratioBand = image.select('VV').divide(image.select('VH')).rename('VV/VH')
  return image.addBands(ratioBand)
}


// Add the VV/VH ratio and apply the RefinedLee Speckle Filter
var speckleFiltered = filtered.map(addRatioBand).map(refinedLee);

// Mosaic and Clip
var sarComposite = speckleFiltered.mosaic().clip(geometry);
var visParams = {bands: ['VV', 'VH', 'VV/VH'], min:[-25, -25, 0] ,max:[0, 0, 2]}

Map.addLayer(sarComposite, visParams, 'SAR RGB Visualization (Refined Lee)'); 


// Speckle Filtering functions
// Credit: SERVIR-Mekong, adapted from
// https://mygeoblog.com/2021/01/21/sentinel-1-speckle-filter-refined-lee/
function powerToDb(img){
  return ee.Image(10).multiply(img.log10());
}
 
function dbToPower(img){
  return ee.Image(10).pow(img.divide(10));
}
 
// The RL speckle filter
function refinedLee(image) {
  var date = image.date();
  var bandNames = image.bandNames();
  image = dbToPower(image);
   
  var result = ee.ImageCollection(bandNames.map(function(b){
    var img = image.select([b]);
     
    // img must be in natural units, i.e. not in dB!
    // Set up 3x3 kernels 
    var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
    var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);
   
    var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
    var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);
   
    // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
    var sample_weights = ee.List([[0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0], [0,1,0,1,0,1,0], [0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0]]);
   
    var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);
   
    // Calculate mean and variance for the sampled windows and store as 9 bands
    var sample_mean = mean3.neighborhoodToBands(sample_kernel); 
    var sample_var = variance3.neighborhoodToBands(sample_kernel);
   
    // Determine the 4 gradients for the sampled windows
    var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs();
    gradients = gradients.addBands(sample_mean.select(6).subtract(sample_mean.select(2)).abs());
    gradients = gradients.addBands(sample_mean.select(3).subtract(sample_mean.select(5)).abs());
    gradients = gradients.addBands(sample_mean.select(0).subtract(sample_mean.select(8)).abs());
   
    // And find the maximum gradient amongst gradient bands
    var max_gradient = gradients.reduce(ee.Reducer.max());
   
    // Create a mask for band pixels that are the maximum gradient
    var gradmask = gradients.eq(max_gradient);
   
    // duplicate gradmask bands: each gradient represents 2 directions
    gradmask = gradmask.addBands(gradmask);
   
    // Determine the 8 directions
    var directions = sample_mean.select(1).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(7))).multiply(1);
    directions = directions.addBands(sample_mean.select(6).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(2))).multiply(2));
    directions = directions.addBands(sample_mean.select(3).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(5))).multiply(3));
    directions = directions.addBands(sample_mean.select(0).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(8))).multiply(4));
    // The next 4 are the not() of the previous 4
    directions = directions.addBands(directions.select(0).not().multiply(5));
    directions = directions.addBands(directions.select(1).not().multiply(6));
    directions = directions.addBands(directions.select(2).not().multiply(7));
    directions = directions.addBands(directions.select(3).not().multiply(8));
   
    // Mask all values that are not 1-8
    directions = directions.updateMask(gradmask);
   
    // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
    directions = directions.reduce(ee.Reducer.sum());  
   
    //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
    //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);
   
    var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean));
   
    // Calculate localNoiseVariance
    var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5).arrayReduce(ee.Reducer.mean(), [0]);
   
    // Set up the 7*7 kernels for directional statistics
    var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3).cat(ee.List.repeat(ee.List.repeat(1,7),4));
   
    var diag_weights = ee.List([[1,0,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,0,0,0,0], 
      [1,1,1,1,0,0,0], [1,1,1,1,1,0,0], [1,1,1,1,1,1,0], [1,1,1,1,1,1,1]]);
   
    var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
    var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);
   
    // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
    var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel).updateMask(directions.eq(1));
    var dir_var = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel).updateMask(directions.eq(1));
   
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel).updateMask(directions.eq(2)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel).updateMask(directions.eq(2)));
   
    // and add the bands for rotated kernels
    for (var i=1; i<4; i++) {
      dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
      dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
      dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
      dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
    }
   
    // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
    dir_mean = dir_mean.reduce(ee.Reducer.sum());
    dir_var = dir_var.reduce(ee.Reducer.sum());
   
    // A finally generate the filtered value
    var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV)).divide(sigmaV.add(1.0));
   
    var b = varX.divide(dir_var);
   
    return dir_mean.add(b.multiply(img.subtract(dir_mean)))
      .arrayProject([0])
      // Get a multi-band image bands.
      .arrayFlatten([['sum']])
      .float();
  })).toBands().rename(bandNames);
  var resultImage = powerToDb(ee.Image(result));
  return resultImage.set('system:time_start', date.millis());
}


// ************************************************************
// Part 2: GAMMA MAP Filter
// ************************************************************
// Source: https://github.com/adugnag/gee_s1_ard/tree/main
var wrapper = require('users/adugnagirma/gee_s1_ard:wrapper');
var helper = require('users/adugnagirma/gee_s1_ard:utilities');

//---------------------------------------------------------------------------//
// DEFINE PARAMETERS
//---------------------------------------------------------------------------//

var parameter = {
  //1. Data Selection
  START_DATE: '2018-08-10',
  STOP_DATE: '2018-08-23',
  POLARIZATION:'VVVH',
  ORBIT : 'DESCENDING',
  GEOMETRY: geometry, 
  
  //2. Additional Border noise correction
  APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION: true,
  
  //3.Speckle filter
  APPLY_SPECKLE_FILTERING: true,
  SPECKLE_FILTER_FRAMEWORK: 'MULTI',
  SPECKLE_FILTER: 'GAMMA MAP',
  SPECKLE_FILTER_KERNEL_SIZE: 9,
  SPECKLE_FILTER_NR_OF_IMAGES: 10,
  
  //4. Radiometric terrain normalization
  APPLY_TERRAIN_FLATTENING: true,
  DEM: ee.Image('USGS/SRTMGL1_003'),
  TERRAIN_FLATTENING_MODEL: 'VOLUME',
  TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER: 0,
  
  //5. Output
  FORMAT : 'DB',
  CLIP_TO_ROI: true,
  SAVE_ASSETS: false
}

// Preprocess the S1 collection
var output = wrapper.s1_preproc(parameter);
var s1 = output[0]
var s1_preprocess = output[1]
// Convert to DB and Add VV/VH ratio band
var speckleFiltered = s1_preprocess
  .map(helper.lin_to_db)
  .map(addRatioBand);

// Visualize
var sarComposite = speckleFiltered.mosaic().clip(geometry);

Map.addLayer(sarComposite, visParams, 'SAR RGB Visualization (GAMMA MAP)'); 
